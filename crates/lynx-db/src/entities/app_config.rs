//! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.4

use anyhow::{Result, anyhow};
use sea_orm::entity::prelude::*;
use serde::{Deserialize, Serialize};
use serde_json::Value as JsonValue;

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[sea_orm(table_name = "app_config")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    #[sea_orm(column_type = "Text")]
    pub key: String,
    #[sea_orm(column_type = "Json")]
    pub value: JsonValue,
    pub description: Option<String>,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {}

impl ActiveModelBehavior for ActiveModel {}

impl Model {
    /// 获取嵌套配置值
    pub fn get_nested_value(&self, path: &[&str]) -> Option<&JsonValue> {
        let mut current = &self.value;
        for &key in path {
            current = current.get(key)?;
        }
        Some(current)
    }

    /// 将配置值转换为特定类型
    pub fn parse_value<T: for<'de> Deserialize<'de>>(&self) -> Result<T> {
        serde_json::from_value(self.value.clone())
            .map_err(|e| anyhow!("Failed to parse config value: {}", e))
    }

    /// 将嵌套配置值转换为特定类型
    pub fn parse_nested_value<T: for<'de> Deserialize<'de>>(&self, path: &[&str]) -> Result<T> {
        let value = self
            .get_nested_value(path)
            .ok_or_else(|| anyhow!("Config path not found: {:?}", path))?;

        serde_json::from_value(value.clone())
            .map_err(|e| anyhow!("Failed to parse config value at {:?}: {}", path, e))
    }
}

pub trait IntoAppConfigModel {
    fn into_app_config_model(self) -> Model;
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::migration::Migrator;
    use sea_orm::{ActiveValue, Database, DatabaseConnection, EntityTrait, Set};
    use sea_orm_migration::MigratorTrait;
    use serde_json::json;

    async fn setup_test_db() -> DatabaseConnection {
        let db = Database::connect("sqlite::memory:").await.unwrap();
        Migrator::up(&db, None).await.unwrap();
        db
    }

    fn create_test_config() -> Model {
        Model {
            id: 1,
            key: "test_config".to_string(),
            value: json!({
                "database": {
                    "host": "localhost",
                    "port": 5432,
                    "settings": {
                        "max_connections": 100
                    }
                }
            }),
            description: Some("Test configuration".to_string()),
        }
    }

    #[tokio::test]
    async fn test_crud_operations() -> Result<()> {
        let db = setup_test_db().await;

        // Create
        let test_config = create_test_config();
        let active_model = ActiveModel {
            id: ActiveValue::NotSet,
            key: Set(test_config.key.clone()),
            value: Set(test_config.value.clone()),
            description: Set(test_config.description.clone()),
        };

        let insert_result = Entity::insert(active_model).exec(&db).await?;
        assert!(insert_result.last_insert_id > 0);

        // Read
        let find_result = Entity::find_by_id(insert_result.last_insert_id)
            .one(&db)
            .await?;
        assert!(find_result.is_some());
        let found = find_result.unwrap();
        assert_eq!(found.key, test_config.key);
        assert_eq!(found.value, test_config.value);
        assert_eq!(found.description, test_config.description);

        // Update
        let mut update_model: ActiveModel = found.clone().into();
        update_model.value = Set(json!({
            "database": {
                "host": "localhost",
                "port": 5433,
                "settings": {
                    "max_connections": 200
                }
            }
        }));

        let update_result = Entity::update(update_model.clone()).exec(&db).await?;
        assert_eq!(update_result.value, update_model.value.unwrap());

        // Delete
        let delete_result = Entity::delete_by_id(update_result.id).exec(&db).await?;
        assert_eq!(delete_result.rows_affected, 1);

        // Verify deletion
        let find_deleted = Entity::find_by_id(update_result.id).one(&db).await?;
        assert!(find_deleted.is_none());

        Ok(())
    }

    #[tokio::test]
    async fn test_update_nested_field() -> Result<()> {
        let db = setup_test_db().await;

        // Create initial config
        let test_config = create_test_config();
        let active_model = ActiveModel {
            id: ActiveValue::NotSet,
            key: Set(test_config.key.clone()),
            value: Set(test_config.value.clone()),
            description: Set(test_config.description.clone()),
        };

        let insert_result = Entity::insert(active_model).exec(&db).await?;

        // Update only the database.host field
        let mut update_model: ActiveModel = Entity::find_by_id(insert_result.last_insert_id)
            .one(&db)
            .await?
            .unwrap()
            .into();

        let mut new_value = update_model.value.unwrap();
        new_value["database"]["host"] = json!("new-host.example.com");
        update_model.value = Set(new_value);

        let update_result = Entity::update(update_model.clone()).exec(&db).await?;

        // Verify only host was changed
        assert_eq!(
            update_result.value["database"]["host"],
            json!("new-host.example.com")
        );
        assert_eq!(update_result.value["database"]["port"], json!(5432));
        assert_eq!(
            update_result.value["database"]["settings"]["max_connections"],
            json!(100)
        );

        Ok(())
    }

    #[test]
    fn test_get_nested_value() {
        let config = create_test_config();

        // Test existing path
        let value = config.get_nested_value(&["database", "host"]);
        assert_eq!(value, Some(&json!("localhost")));

        // Test nested path
        let value = config.get_nested_value(&["database", "settings", "max_connections"]);
        assert_eq!(value, Some(&json!(100)));

        // Test non-existent path
        let value = config.get_nested_value(&["non", "existent", "path"]);
        assert_eq!(value, None);
    }

    #[test]
    fn test_parse_value() {
        let config = create_test_config();

        #[derive(Debug, Deserialize, PartialEq)]
        struct DatabaseConfig {
            host: String,
            port: i32,
            settings: Settings,
        }

        #[derive(Debug, Deserialize, PartialEq)]
        struct Settings {
            max_connections: i32,
        }

        #[derive(Debug, Deserialize, PartialEq)]
        struct FullConfig {
            database: DatabaseConfig,
        }

        let parsed: FullConfig = config.parse_value().unwrap();
        assert_eq!(parsed.database.host, "localhost");
        assert_eq!(parsed.database.port, 5432);
        assert_eq!(parsed.database.settings.max_connections, 100);
    }

    #[test]
    fn test_parse_nested_value() {
        let config = create_test_config();

        // Test parsing a simple value
        let host: String = config.parse_nested_value(&["database", "host"]).unwrap();
        assert_eq!(host, "localhost");

        // Test parsing a number
        let port: i32 = config.parse_nested_value(&["database", "port"]).unwrap();
        assert_eq!(port, 5432);

        // Test parsing an object
        #[derive(Debug, Deserialize, PartialEq)]
        struct Settings {
            max_connections: i32,
        }
        let settings: Settings = config
            .parse_nested_value(&["database", "settings"])
            .unwrap();
        assert_eq!(settings.max_connections, 100);

        // Test error case - invalid path
        let result: Result<String> = config.parse_nested_value(&["invalid", "path"]);
        assert!(result.is_err());
    }

    #[test]
    fn test_into_app_config_model() {
        #[derive(Debug)]
        struct TestConfig {
            name: String,
            value: i32,
        }

        impl IntoAppConfigModel for TestConfig {
            fn into_app_config_model(self) -> Model {
                Model {
                    id: 0,
                    key: self.name,
                    value: json!({ "value": self.value }),
                    description: None,
                }
            }
        }

        let test_config = TestConfig {
            name: "test".to_string(),
            value: 42,
        };

        let model = test_config.into_app_config_model();
        assert_eq!(model.key, "test");
        assert_eq!(model.value.get("value").unwrap(), 42);
    }
}
